Stammpatienten <- allRawData[allRawData$Stammpatient %in% c("1"), ]
fct(paste0(funtionType, " bezueglich Stammpatienten"), Stammpatienten)
mtext(paste0("Alle Praxen zusammengelegt - ", funtionType), side = 3, line = -0.1, outer = TRUE)
}
if  ((patientType == 0) || (patientType == -1)) {
# Datensatz fuer Nicht-Stammpatienten
NichtStammpatienten <- allRawData[allRawData$Stammpatient %in% c("0"), ]
fct(paste0(funtionType, " bezueglich Nicht-Stammpatienten"), NichtStammpatienten)
mtext(paste0("Alle Praxen zusammengelegt - ", funtionType), side = 3, line = -0.1, outer = TRUE)
}
if (patientType == -1) {
# Datensatz fuer alle Patienten
fct(paste0(funtionType, " bezueglich allen Patienten"), allRawData)
mtext(paste0("Alle Praxen zusammengelegt - ", funtionType), side = 3, line = -0.1, outer = TRUE)
}
}
print_explanation <- function (header, text) {
par(mfrow = c(1, 1), oma = c(2,1,4,1) + 0.1,  mar = c(0,1,4,1) + 0.1)
print_output(header, text);
}
percent <- function(x, digits = 2, format = "f") {
paste0(format(100 * x, format = format, digits = (digits + 2)), "%")
}
## Setup
###########
# Falls modData auf TRUE gesetzt wird, wird eine Funktion modDataFunction erwartet
# die die Input-Daten im Argument erhält und diese modifiziert wieder zurückgibt
modData = FALSE;
# Falls forEveryDoc auf TRUE gesetzt ist, so wird für jede Praxis mit mehr als einem Arzt
# zusätzlich zu der Untersuchung bzgl. der Gesamtpraxis auch die Untersuchung für jeden Arzt durchgeführt
forEveryDoc = TRUE;
# boolean: NutzeTagesSpannen
#  - falls FALSE wird Regression ueber alle IndirectWaitingPerdiod erstellt
#  - falls TRUE wird fuer jeden Vector c(a, b) in der Liste tagesSpannen jeweils eine Regression fuer IndirectWaitingPerdiod in [a, b] erstellt
NutzeTagesSpannen = FALSE;
tagesSpannen <- list( c(0, 7), c(8,14), c(15, 56), c(57, 250) )
source("functions.R")
# Die Regression die wir durchfuehren moechten, definieren wir hier
calc_binReg <- function(dataset) {
#result <- glm(Attended ~ freeSlots + shortSlots + bookedSlots, data = dataset, family = binomial)
result <- glm(Attended ~ IndirectWaitingPeriod + Metrik1 + Metrik2, data = dataset, family = binomial)
return(result)
}
# Die Print-Funktion die speziell für Regressionen angepasst ist definieren wir hier
dailyAppointmentsVsFuture <- function(title, data) {
print_reg(title, data, calc_binReg)
}
# Title-Seite zum späteren Füllen mit Beschreibung/Erklärung
print_explanation("Attended Binomal Regressions", "Text");
## Auszuführendes Skript übergeben, sodass es jeweils für alle Praxen ausgeführt wird
# execFunctionForAllAgencies(fct, patientType, mfrowCount1, mfrowCount2, funtionType) :
# - fct: die oben definierte Funktion, die für jede Praxis einzeln und für alle gemeinsam ausgeführt werden soll
# - patientType: für welche Patienten soll es durchgeführt werden, -1: alle Patienten, 1: Stammpatienten, 0: Nicht-Stammpatienten
# - mfrowCount1: Anzahl der Spalten von Plots pro Seite
# - mfrowCount2: Anzahl der Zeilen von Plots pro Seite
# - funtionType: Beschreibung der Funktion
execFunctionForAllAgencies(dailyAppointmentsVsFuture, -1, 3, 1, "Binomiale Regression")
View(testesttest1)
data2 <- rbind(testesttest1, testesttest2)
data <- rbind(data2, testesttest3)
View(data)
newData1 <- select(data, -c(EventTimestamp))
View(newData1)
newData1$WalkIn <- ifelse( (as.character(data$EventSubmitDay) == as.character(data$EventDay)), 1, 0 )
View(newData1)
http://www.sthda.com/english/wiki/exporting-data-from-r
write.csv2(newData1, file = "mnewData1tcars.csv")
## Setup
###########
# Falls modData auf TRUE gesetzt wird, wird eine Funktion modDataFunction erwartet
# die die Input-Daten im Argument erhält und diese modifiziert wieder zurückgibt
modData = FALSE;
# Falls forEveryDoc auf TRUE gesetzt ist, so wird für jede Praxis mit mehr als einem Arzt
# zusätzlich zu der Untersuchung bzgl. der Gesamtpraxis auch die Untersuchung für jeden Arzt durchgeführt
forEveryDoc = TRUE;
# boolean: NutzeTagesSpannen
#  - falls FALSE wird Regression ueber alle IndirectWaitingPerdiod erstellt
#  - falls TRUE wird fuer jeden Vector c(a, b) in der Liste tagesSpannen jeweils eine Regression fuer IndirectWaitingPerdiod in [a, b] erstellt
NutzeTagesSpannen = FALSE;
tagesSpannen <- list( c(0, 7), c(8,14), c(15, 56), c(57, 250) )
source("functions.R")
# Die Regression die wir durchfuehren moechten, definieren wir hier
calc_binReg <- function(dataset) {
#result <- glm(Attended ~ freeSlots + shortSlots + bookedSlots, data = dataset, family = binomial)
result <- 0
return(result)
}
# Die Print-Funktion die speziell für Regressionen angepasst ist definieren wir hier
dailyAppointmentsVsFuture <- function(title, data) {
print_reg(title, data, calc_binReg)
}
# Title-Seite zum späteren Füllen mit Beschreibung/Erklärung
print_explanation("Attended Binomal Regressions", "Text");
## Auszuführendes Skript übergeben, sodass es jeweils für alle Praxen ausgeführt wird
# execFunctionForAllAgencies(fct, patientType, mfrowCount1, mfrowCount2, funtionType) :
# - fct: die oben definierte Funktion, die für jede Praxis einzeln und für alle gemeinsam ausgeführt werden soll
# - patientType: für welche Patienten soll es durchgeführt werden, -1: alle Patienten, 1: Stammpatienten, 0: Nicht-Stammpatienten
# - mfrowCount1: Anzahl der Spalten von Plots pro Seite
# - mfrowCount2: Anzahl der Zeilen von Plots pro Seite
# - funtionType: Beschreibung der Funktion
pdf(paste0(substr(basename(rstudioapi::getSourceEditorContext()$path), 1, nchar(basename(rstudioapi::getSourceEditorContext()$path))-1),'pdf'))
execFunctionForAllAgencies(dailyAppointmentsVsFuture, -1, 1, 1, "Binomiale Regression")
dev.off()
execFunctionForAllAgencies(dailyAppointmentsVsFuture, -1, 1, 1, "Binomiale Regression")
## Setup
###########
## Configuration
# Falls modData auf TRUE gesetzt wird, wird eine Funktion modDataFunction erwartet
# die die input daten als Argument erhält und diese modifiziert wieder zurückgibt
modData = FALSE;
# Falls forEveryDoc auf TRUE gesetzt wird, so wird für jede Praxis mit mehr als einem Arzt
# zusätzlich zu der Untersuchung auf der Gesamtpraxis auch die Untersuchung für jeden Arzt durchgeführt
forEveryDoc = FALSE;
# boolean: NutzeTagesSpannen
#  - falls FALSE wird Regression ueber alle IndirectWaitingPerdiod erstellt
#  - falls TRUE wird fuer jeden Vector c(a, b) in der Liste tagesSpannen jeweils eine Regression fuer IndirectWaitingPerdiod in [a, b] erstellt
NutzeTagesSpannen = FALSE;
tagesSpannen <- list( c(0, 7), c(8,14), c(15, 56), c(57, 250) )
source("functions.R")
# Die Regression die wir durchfuehren moechten, definieren wir hier
calc_binReg <- function(data) {
if ((!is.null(data)) && (length(data[,1]) > 0)) {
Patienten <- data
Patienten$DaysFromDueToNextSubmit <- ceiling( Patienten$msToNextSDateFromPrevDDate / (1000*60*60*24) );
# msToNextxDate enthaelt den nächsten Termin, dessen Submit-Date (Termineintrag) älter ist, als das aktuelle Submit Datum
# Die Differenz zum Due-Date (Arzttermin) kann somit aber sowohl positiv als auch negativ sein
PatientenPDTN <- Patienten[Patienten$DaysFromDueToNextSubmit == 0, ]
if (length(PatientenPDTN[,1]) > 0) {
PatientenPDTN$PositiveDueToSubmit <- 1
}
PatientenNDTN <- Patienten[Patienten$DaysFromDueToNextSubmit > 0,  ]
if (length(PatientenNDTN[,1]) > 0) {
PatientenNDTN$PositiveDueToSubmit <- 0
}
PatientenDTN <- rbind(PatientenPDTN, PatientenNDTN)
result <- glm(PositiveDueToSubmit ~ CountOfCurrentAppointments, data = PatientenDTN, family = binomial)
return(result)
}
}
# Die Print-Funktion die speziell für Regressionen angepasst ist definieren wir hier
daysFromDueToNextSubmitVsAttended <- function(title, data) {
print_reg(title, data, calc_binReg)
}
# Title-Seite zum späteren Füllen mit Beschreibung/Erklärung
print_explanation("Nur Stammpatienten - Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine", "");
## Auszuführendes Skript übergeben, sodass es jeweils für alle Praxen ausgeführt wird
# execFunctionForAllAgencies(fct, patientType, mfrowCount1, mfrowCount2, funtionType) :
# - fct: die oben definierte Funktion, die für jede Praxis einzeln und für alle gemeinsam ausgeführt werden soll
# - patientType: für welche Patienten soll es durchgeführt werden, -1: alle Patienten, 1: Stammpatienten, 0: Nicht-Stammpatienten
# - mfrowCount1: Anzahl der Spalten von Plots pro Seite
# - mfrowCount2: Anzahl der Zeilen von Plots pro Seite
# - funtionType: Beschreibung der Funktion
pdf(paste0(substr(basename(rstudioapi::getSourceEditorContext()$path), 1, nchar(basename(rstudioapi::getSourceEditorContext()$path))-1),'pdf'))
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
dev.off()
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
## Setup
###########
## Configuration
# Falls modData auf TRUE gesetzt wird, wird eine Funktion modDataFunction erwartet
# die die input daten als Argument erhält und diese modifiziert wieder zurückgibt
modData = FALSE;
# Falls forEveryDoc auf TRUE gesetzt wird, so wird für jede Praxis mit mehr als einem Arzt
# zusätzlich zu der Untersuchung auf der Gesamtpraxis auch die Untersuchung für jeden Arzt durchgeführt
forEveryDoc = FALSE;
# boolean: NutzeTagesSpannen
#  - falls FALSE wird Regression ueber alle IndirectWaitingPerdiod erstellt
#  - falls TRUE wird fuer jeden Vector c(a, b) in der Liste tagesSpannen jeweils eine Regression fuer IndirectWaitingPerdiod in [a, b] erstellt
NutzeTagesSpannen = FALSE;
tagesSpannen <- list( c(0, 7), c(8,14), c(15, 56), c(57, 250) )
source("functions.R")
# Die Regression die wir durchfuehren moechten, definieren wir hier
calc_binReg <- function(data) {
if ((!is.null(data)) && (length(data[,1]) > 0)) {
Patienten <<- data
#Patienten$DaysFromDueToNextSubmit <- ceiling( Patienten$msToNextSDateFromPrevDDate / (1000*60*60*24) );
# msToNextxDate enthaelt den nächsten Termin, dessen Submit-Date (Termineintrag) älter ist, als das aktuelle Submit Datum
# Die Differenz zum Due-Date (Arzttermin) kann somit aber sowohl positiv als auch negativ sein
PatientenPDTN <- Patienten[Patienten$DaysFromDueToNextSubmit == 0, ]
if (length(PatientenPDTN[,1]) > 0) {
PatientenPDTN$PositiveDueToSubmit <- 1
}
PatientenNDTN <- Patienten[Patienten$DaysFromDueToNextSubmit > 0,  ]
if (length(PatientenNDTN[,1]) > 0) {
PatientenNDTN$PositiveDueToSubmit <- 0
}
PatientenDTN <- rbind(PatientenPDTN, PatientenNDTN)
result <- glm(PositiveDueToSubmit ~ CountOfCurrentAppointments, data = PatientenDTN, family = binomial)
return(result)
}
}
# Die Print-Funktion die speziell für Regressionen angepasst ist definieren wir hier
daysFromDueToNextSubmitVsAttended <- function(title, data) {
print_reg(title, data, calc_binReg)
}
# Title-Seite zum späteren Füllen mit Beschreibung/Erklärung
print_explanation("Nur Stammpatienten - Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine", "");
## Auszuführendes Skript übergeben, sodass es jeweils für alle Praxen ausgeführt wird
# execFunctionForAllAgencies(fct, patientType, mfrowCount1, mfrowCount2, funtionType) :
# - fct: die oben definierte Funktion, die für jede Praxis einzeln und für alle gemeinsam ausgeführt werden soll
# - patientType: für welche Patienten soll es durchgeführt werden, -1: alle Patienten, 1: Stammpatienten, 0: Nicht-Stammpatienten
# - mfrowCount1: Anzahl der Spalten von Plots pro Seite
# - mfrowCount2: Anzahl der Zeilen von Plots pro Seite
# - funtionType: Beschreibung der Funktion
pdf(paste0(substr(basename(rstudioapi::getSourceEditorContext()$path), 1, nchar(basename(rstudioapi::getSourceEditorContext()$path))-1),'pdf'))
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
dev.off()
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
View(appointmentsNT)
## Setup
###########
## Configuration
# Falls modData auf TRUE gesetzt wird, wird eine Funktion modDataFunction erwartet
# die die input daten als Argument erhält und diese modifiziert wieder zurückgibt
modData = FALSE;
# Falls forEveryDoc auf TRUE gesetzt wird, so wird für jede Praxis mit mehr als einem Arzt
# zusätzlich zu der Untersuchung auf der Gesamtpraxis auch die Untersuchung für jeden Arzt durchgeführt
forEveryDoc = FALSE;
# boolean: NutzeTagesSpannen
#  - falls FALSE wird Regression ueber alle IndirectWaitingPerdiod erstellt
#  - falls TRUE wird fuer jeden Vector c(a, b) in der Liste tagesSpannen jeweils eine Regression fuer IndirectWaitingPerdiod in [a, b] erstellt
NutzeTagesSpannen = FALSE;
tagesSpannen <- list( c(0, 7), c(8,14), c(15, 56), c(57, 250) )
source("functions.R")
# Die Regression die wir durchfuehren moechten, definieren wir hier
calc_binReg <- function(data) {
if ((!is.null(data)) && (length(data[,1]) > 0)) {
Patienten <<- data
Patienten$DaysFromDueToNextSubmit <- ceiling( Patienten$msToNextSDateFromPrevDDate / (1000*60*60*24) );
# msToNextxDate enthaelt den nächsten Termin, dessen Submit-Date (Termineintrag) älter ist, als das aktuelle Submit Datum
# Die Differenz zum Due-Date (Arzttermin) kann somit aber sowohl positiv als auch negativ sein
PatientenPDTN <- Patienten[Patienten$DaysFromDueToNextSubmit == 0, ]
print(length(PatientenPDTN[,1]))
if (length(PatientenPDTN[,1]) > 0) {
PatientenPDTN$PositiveDueToSubmit <- 1
}
PatientenNDTN <- Patienten[Patienten$DaysFromDueToNextSubmit > 0,  ]
print(length(PatientenNDTN[,1]))
if (length(PatientenNDTN[,1]) > 0) {
PatientenNDTN$PositiveDueToSubmit <- 0
}
PatientenDTN <- rbind(PatientenPDTN, PatientenNDTN)
result <- glm(PositiveDueToSubmit ~ CountOfCurrentAppointments, data = PatientenDTN, family = binomial)
return(result)
}
}
# Die Print-Funktion die speziell für Regressionen angepasst ist definieren wir hier
daysFromDueToNextSubmitVsAttended <- function(title, data) {
print_reg(title, data, calc_binReg)
}
# Title-Seite zum späteren Füllen mit Beschreibung/Erklärung
print_explanation("Nur Stammpatienten - Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine", "");
## Auszuführendes Skript übergeben, sodass es jeweils für alle Praxen ausgeführt wird
# execFunctionForAllAgencies(fct, patientType, mfrowCount1, mfrowCount2, funtionType) :
# - fct: die oben definierte Funktion, die für jede Praxis einzeln und für alle gemeinsam ausgeführt werden soll
# - patientType: für welche Patienten soll es durchgeführt werden, -1: alle Patienten, 1: Stammpatienten, 0: Nicht-Stammpatienten
# - mfrowCount1: Anzahl der Spalten von Plots pro Seite
# - mfrowCount2: Anzahl der Zeilen von Plots pro Seite
# - funtionType: Beschreibung der Funktion
pdf(paste0(substr(basename(rstudioapi::getSourceEditorContext()$path), 1, nchar(basename(rstudioapi::getSourceEditorContext()$path))-1),'pdf'))
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
dev.off()
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
## Setup
###########
## Configuration
# Falls modData auf TRUE gesetzt wird, wird eine Funktion modDataFunction erwartet
# die die input daten als Argument erhält und diese modifiziert wieder zurückgibt
modData = FALSE;
# Falls forEveryDoc auf TRUE gesetzt wird, so wird für jede Praxis mit mehr als einem Arzt
# zusätzlich zu der Untersuchung auf der Gesamtpraxis auch die Untersuchung für jeden Arzt durchgeführt
forEveryDoc = FALSE;
# boolean: NutzeTagesSpannen
#  - falls FALSE wird Regression ueber alle IndirectWaitingPerdiod erstellt
#  - falls TRUE wird fuer jeden Vector c(a, b) in der Liste tagesSpannen jeweils eine Regression fuer IndirectWaitingPerdiod in [a, b] erstellt
NutzeTagesSpannen = FALSE;
tagesSpannen <- list( c(0, 7), c(8,14), c(15, 56), c(57, 250) )
source("functions.R")
# Die Regression die wir durchfuehren moechten, definieren wir hier
calc_binReg <- function(data) {
if ((!is.null(data)) && (length(data[,1]) > 0)) {
Patienten <<- data
Patienten$DaysFromDueToNextSubmit <- ceiling( as.numeric(Patienten$msToNextSDateFromPrevDDate) / (1000*60*60*24) );
# msToNextxDate enthaelt den nächsten Termin, dessen Submit-Date (Termineintrag) älter ist, als das aktuelle Submit Datum
# Die Differenz zum Due-Date (Arzttermin) kann somit aber sowohl positiv als auch negativ sein
PatientenPDTN <- Patienten[Patienten$DaysFromDueToNextSubmit == 0, ]
print(length(PatientenPDTN[,1]))
if (length(PatientenPDTN[,1]) > 0) {
PatientenPDTN$PositiveDueToSubmit <- 1
}
PatientenNDTN <- Patienten[Patienten$DaysFromDueToNextSubmit > 0,  ]
print(length(PatientenNDTN[,1]))
if (length(PatientenNDTN[,1]) > 0) {
PatientenNDTN$PositiveDueToSubmit <- 0
}
PatientenDTN <- rbind(PatientenPDTN, PatientenNDTN)
result <- glm(PositiveDueToSubmit ~ CountOfCurrentAppointments, data = PatientenDTN, family = binomial)
return(result)
}
}
# Die Print-Funktion die speziell für Regressionen angepasst ist definieren wir hier
daysFromDueToNextSubmitVsAttended <- function(title, data) {
print_reg(title, data, calc_binReg)
}
# Title-Seite zum späteren Füllen mit Beschreibung/Erklärung
print_explanation("Nur Stammpatienten - Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine", "");
## Auszuführendes Skript übergeben, sodass es jeweils für alle Praxen ausgeführt wird
# execFunctionForAllAgencies(fct, patientType, mfrowCount1, mfrowCount2, funtionType) :
# - fct: die oben definierte Funktion, die für jede Praxis einzeln und für alle gemeinsam ausgeführt werden soll
# - patientType: für welche Patienten soll es durchgeführt werden, -1: alle Patienten, 1: Stammpatienten, 0: Nicht-Stammpatienten
# - mfrowCount1: Anzahl der Spalten von Plots pro Seite
# - mfrowCount2: Anzahl der Zeilen von Plots pro Seite
# - funtionType: Beschreibung der Funktion
pdf(paste0(substr(basename(rstudioapi::getSourceEditorContext()$path), 1, nchar(basename(rstudioapi::getSourceEditorContext()$path))-1),'pdf'))
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
dev.off()
execFunctionForAllAgencies(daysFromDueToNextSubmitVsAttended, 1, 1, 1, "Bin. Regression DueToSubmit positiv bzgl. Anzahl bestehender Termine")
Q
Q
Q
Q
# Datei muss zwei mal hintereinander ausgeführt werden.
library(rlang)
# Definiere Funktion die für alle Ärzte und Praxen ausgeführt werden soll
# einziger Input ist der dataset und return ist der Output
lngth <- function(dataset) {
return ( length(dataset[,1]) );
}
# Gebe oben definierte Funktion an und wähle zwischen:
# - print: Ausgabe in Console
# - plot: Ausgabe in Plot
# - export: Plotausgabe in gleichnamige PDF
execFunctionForAllAgencies(lngth, "print");
###############################################
## Ab hier sollte nichts mehr geändert werden
execFunctionForAllAgencies <- function(fct, mode) {
if (mode == "export") {
pdf(paste0(substr(basename(rstudioapi::getSourceEditorContext()$path), 1, nchar(basename(rstudioapi::getSourceEditorContext()$path))-1),'pdf'))
paramMode <- "plot";
} else { paramMode <- mode; }
data <- loadData('data');
# Variable global betrachtbar
assign("df", data, envir = .GlobalEnv)
praxen <- c('B', 'IML','WD')
for (i in 1:(length(praxen) + 1)) {
if ( i <= length(praxen)) {
agencyData <- data[as.character(data$Agency) ==  praxen[i],]
agencyText <- paste0("Praxis ",  praxen[i]);
} else {
agencyData <- data
agencyText <- "Alle Praxen zusammengelegt";
}
# Anzahl an Aerzten in der Praxis
docs <- switch(i, 1, 4, 2, 0)
for (j in 1:(docs + 1)) {
if ( i <= length(praxen)) {
if ( j <= docs) {
docData <- agencyData[as.numeric(agencyData$AgentTag) ==  j,]
docText <- paste0(" - bei Arzt ", j);
} else {
docData <- agencyData
docText <- " - alle Aerzte zusammengelegt";
}
} else {
docData <- agencyData
docText <- "";
}
# Stammpatienten (patientType = 1), Nicht-Stammpatienten (patientType = 0), ansonsten alle
patientType <- c(0, 1)
for (k in 1:(length(patientType) + 1)) {
if ( k <= length(patientType)) {
finalData <- docData[as.numeric(docData$Stammpatient) == patientType[k],]
if (k == 1) {
typeText <- " - fuer Nicht-Stammpatienten";
} else {  typeText <- " - fuer Stammpatienten"; }
} else {
finalData <- docData;
typeText <- " - fuer alle Patienten";
}
if ((!is_empty(finalData)) && (length(finalData[, 1]) > 0)) {
print_output(paramMode, paste0(agencyText, docText, typeText), fct(finalData))
}
}
}
}
if (mode == "export") {dev.off() }
}
print_output <- function(mode, header, output, cex = 0.75) {
if (mode == "plot") {
tmp <- capture.output(output)
plot.new()
title(header, cex.main = 1.25 * cex, line = 0.5)
text(0, 1, paste0(tmp, collapse='\n'), adj = c(0,1), family = 'mono', cex = cex)
box()
} else  {
print(header)
print(output)
}
}
loadData <- function(filename) {
workingDirectory <- dirname(rstudioapi::getSourceEditorContext()$path)
data <- read.csv2(paste0(workingDirectory, '/',filename,'.csv'), sep = ";", quote = "\"'", dec = ",")
sapply(data, class)
return(data);
}
# data$X, data$AgentTag, data$EventSubmitDay, data$EventDay
# data$EventTimestamp, data$TimeSlotAsInt, data$TimeSlotAsString
# data$PatientID, data$PatientAge, data$IndirectWaitingPeriod
# data$Metrik1, data$Metrik2, data$freeSlots
# data$shortSlots, data$bookedSlots, data$CountOfCurrentAppointments
# data$msToNextDDateFromPrevDDate, data$msToNextSDateFromPrevDDate, data$numberOfSlots
# data$slotsToNextPossibleEventDate, data$minsToNextPossibleEventDate, data$Attended,
# data$Stammpatient, data$WalkIn, data$CountOfDailyAppointmentsPerAgency,
# data$SumOfFutureAppointmentsPerAgency, data$CountOfDailyAppointmentsPerAgent, data$SumOfFutureAppointmentsPerAgent
# Datei muss zwei mal hintereinander ausgeführt werden.
library(rlang)
# Definiere Funktion die für alle Ärzte und Praxen ausgeführt werden soll
# einziger Input ist der dataset und return ist der Output
lngth <- function(dataset) {
return ( length(dataset[,1]) );
}
# Gebe oben definierte Funktion an und wähle zwischen:
# - print: Ausgabe in Console
# - plot: Ausgabe in Plot
# - export: Plotausgabe in gleichnamige PDF
execFunctionForAllAgencies(lngth, "print");
###############################################
## Ab hier sollte nichts mehr geändert werden
execFunctionForAllAgencies <- function(fct, mode) {
if (mode == "export") {
pdf(paste0(substr(basename(rstudioapi::getSourceEditorContext()$path), 1, nchar(basename(rstudioapi::getSourceEditorContext()$path))-1),'pdf'))
paramMode <- "plot";
} else { paramMode <- mode; }
data <- loadData('data');
# Variable global betrachtbar
assign("df", data, envir = .GlobalEnv)
praxen <- c('B', 'IML','WD')
for (i in 1:(length(praxen) + 1)) {
if ( i <= length(praxen)) {
agencyData <- data[as.character(data$Agency) ==  praxen[i],]
agencyText <- paste0("Praxis ",  praxen[i]);
} else {
agencyData <- data
agencyText <- "Alle Praxen zusammengelegt";
}
# Anzahl an Aerzten in der Praxis
docs <- switch(i, 1, 4, 2, 0)
for (j in 1:(docs + 1)) {
if ( i <= length(praxen)) {
if ( j <= docs) {
docData <- agencyData[as.numeric(agencyData$AgentTag) ==  j,]
docText <- paste0(" - bei Arzt ", j);
} else {
docData <- agencyData
docText <- " - alle Aerzte zusammengelegt";
}
} else {
docData <- agencyData
docText <- "";
}
# Stammpatienten (patientType = 1), Nicht-Stammpatienten (patientType = 0), ansonsten alle
patientType <- c(0, 1)
for (k in 1:(length(patientType) + 1)) {
if ( k <= length(patientType)) {
finalData <- docData[as.numeric(docData$Stammpatient) == patientType[k],]
if (k == 1) {
typeText <- " - fuer Nicht-Stammpatienten";
} else {  typeText <- " - fuer Stammpatienten"; }
} else {
finalData <- docData;
typeText <- " - fuer alle Patienten";
}
if ((!is_empty(finalData)) && (length(finalData[, 1]) > 0)) {
print_output(paramMode, paste0(agencyText, docText, typeText), fct(finalData))
}
}
}
}
if (mode == "export") {dev.off() }
}
print_output <- function(mode, header, output, cex = 0.75) {
if (mode == "plot") {
tmp <- capture.output(output)
plot.new()
title(header, cex.main = 1.25 * cex, line = 0.5)
text(0, 1, paste0(tmp, collapse='\n'), adj = c(0,1), family = 'mono', cex = cex)
box()
} else  {
print(header)
print(output)
}
}
loadData <- function(filename) {
workingDirectory <- dirname(rstudioapi::getSourceEditorContext()$path)
data <- read.csv2(paste0(workingDirectory, '/',filename,'.csv'), sep = ";", quote = "\"'", dec = ",")
sapply(data, class)
return(data);
}
# data$X, data$AgentTag, data$EventSubmitDay, data$EventDay
# data$EventTimestamp, data$TimeSlotAsInt, data$TimeSlotAsString
# data$PatientID, data$PatientAge, data$IndirectWaitingPeriod
# data$Metrik1, data$Metrik2, data$freeSlots
# data$shortSlots, data$bookedSlots, data$CountOfCurrentAppointments
# data$msToNextDDateFromPrevDDate, data$msToNextSDateFromPrevDDate, data$numberOfSlots
# data$slotsToNextPossibleEventDate, data$minsToNextPossibleEventDate, data$Attended,
# data$Stammpatient, data$WalkIn, data$CountOfDailyAppointmentsPerAgency,
# data$SumOfFutureAppointmentsPerAgency, data$CountOfDailyAppointmentsPerAgent, data$SumOfFutureAppointmentsPerAgent
View(df)
t = 6.05e+10 - 5.79e+10
t
t / (60 * 60 * 24)
11111
